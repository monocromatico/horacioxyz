<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Grid Walk - Explicado</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
<script>
  // 1. Creamos una escena tridimensional
  const scene = new THREE.Scene();

  // 2. Configuramos una cámara con perspectiva
  //    - 75° de campo de visión vertical
  //    - Proporción (ancho/alto) del viewport
  //    - Planos de recorte cercano (0.1) y lejano (100)
  const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 100);

  // Posicionamos la cámara (x=0, y=3, z=5)
  // Esto simula una vista ligeramente desde arriba, mirando hacia el origen
  camera.position.set(0, 2, 9);
  camera.lookAt(0, 0, 0); // Mirando hacia el centro de la escena

  // 3. Creamos el renderer y lo añadimos al DOM
  const renderer = new THREE.WebGLRenderer({ antialias: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // 4. Definimos los parámetros globales (uniforms) para el shader
  const uniforms = {
    // Tiempo en segundos, usado para animar (lo modificaremos cada frame)
    u_time: { value: 0.0 },

    // Color de las líneas de la cuadrícula (puede ser RGB o HEX)
    u_lineColor: { value: new THREE.Color('#ffffff') }, // Cyan

    // Color de fondo entre líneas
    u_bgColor: { value: new THREE.Color('#000000') } // Negro
  };

  // 5. Creamos una geometría de plano (grid)
  // - Ancho: 100 unidades (eje X)
  // - Profundidad: 100 unidades (eje Z)
  // - Segmentos: 100 x 100 (más segmentos = más UVs disponibles para detalle)
  const geometry = new THREE.PlaneGeometry(100, 100, 100, 100);

  // 6. Creamos un ShaderMaterial personalizado
  const material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: `
      // Transmitimos las coordenadas UV al fragment shader
      varying vec2 vUv;

      void main() {
        vUv = uv; // UV es una coordenada 2D entre (0, 0) y (1, 1)
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;

      uniform float u_time;       // Tiempo animado en segundos
      uniform vec3 u_lineColor;   // Color de las líneas
      uniform vec3 u_bgColor;     // Color de fondo

      void main() {
        // Frecuencia de líneas: 100 ciclos a lo largo de 1 unidad UV (0–1)
        // Esto da 100 líneas en X y Y, visualmente distribuidas por la geometría
        float frequency = 100.0;

        // Grosor de línea: menor = más delgada
        float thickness = .999991;

        // Calculamos líneas verticales: sinusoide periódica en X
        float lineX = step(thickness, abs(sin(frequency * vUv.x)));

        // Calculamos líneas horizontales: desplazadas en el tiempo para animar
        // INVERTIMOS dirección restando tiempo (si fuera +u_time, va "al frente")
        float lineY = step(thickness, abs(sin(frequency * (vUv.y + u_time * 0.1))));

        // Sumamos ambas para obtener cuadrícula
        float lines = clamp(lineX + lineY, 0.0, 1.0);

        // Mezclamos el color según presencia de líneas
        vec3 color = mix(u_bgColor, u_lineColor, lines);

        gl_FragColor = vec4(color, 1.0); // 1.0 = opacidad completa
      }
    `,
    side: THREE.DoubleSide // El plano puede verse desde ambos lados
  });

  // 7. Creamos el mesh (forma + material) y lo rotamos
  const grid = new THREE.Mesh(geometry, material);

  // Por defecto, el plano está en el plano XY, lo rotamos a horizontal (plano XZ)
  grid.rotation.x = -Math.PI / 2;

  scene.add(grid); // Añadimos el plano a la escena

  // 8. Animamos en bucle
  function animate(time) {
    requestAnimationFrame(animate);

    // Convertimos el tiempo de milisegundos a segundos y lo pasamos al shader
    uniforms.u_time.value = time * 0.00005;

    // Renderizamos la escena desde la perspectiva de la cámara
    renderer.render(scene, camera);
  }

  animate(); // Comenzamos la animación
</script>
</body>
</html>
