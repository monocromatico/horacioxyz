<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Grid Walk - Explicado</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
<script>
  // üß± 1. Creamos una escena tridimensional
  const scene = new THREE.Scene();

  // üé• 2. Configuramos una c√°mara con perspectiva
  //    - 75¬∞ de campo de visi√≥n vertical
  //    - Proporci√≥n (ancho/alto) del viewport
  //    - Planos de recorte cercano (0.1) y lejano (100)
  const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 100);

  // Posicionamos la c√°mara (x=0, y=3, z=5)
  // Esto simula una vista ligeramente desde arriba, mirando hacia el origen
  camera.position.set(0, 2, 9);
  camera.lookAt(0, 0, 0); // Mirando hacia el centro de la escena

  // üñºÔ∏è 3. Creamos el renderer y lo a√±adimos al DOM
  const renderer = new THREE.WebGLRenderer({ antialias: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // üé® 4. Definimos los par√°metros globales (uniforms) para el shader
  const uniforms = {
    // Tiempo en segundos, usado para animar (lo modificaremos cada frame)
    u_time: { value: 0.0 },

    // Color de las l√≠neas de la cuadr√≠cula (puede ser RGB o HEX)
    u_lineColor: { value: new THREE.Color('#ffffff') }, // Cyan

    // Color de fondo entre l√≠neas
    u_bgColor: { value: new THREE.Color('#000000') } // Negro
  };

  // üìê 5. Creamos una geometr√≠a de plano (grid)
  // - Ancho: 100 unidades (eje X)
  // - Profundidad: 100 unidades (eje Z)
  // - Segmentos: 100 x 100 (m√°s segmentos = m√°s UVs disponibles para detalle)
  const geometry = new THREE.PlaneGeometry(100, 100, 100, 100);

  // üß† 6. Creamos un ShaderMaterial personalizado
  const material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: `
      // Transmitimos las coordenadas UV al fragment shader
      varying vec2 vUv;

      void main() {
        vUv = uv; // UV es una coordenada 2D entre (0, 0) y (1, 1)
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;

      uniform float u_time;       // Tiempo animado en segundos
      uniform vec3 u_lineColor;   // Color de las l√≠neas
      uniform vec3 u_bgColor;     // Color de fondo

      void main() {
        // Frecuencia de l√≠neas: 100 ciclos a lo largo de 1 unidad UV (0‚Äì1)
        // Esto da 100 l√≠neas en X y Y, visualmente distribuidas por la geometr√≠a
        float frequency = 100.0;

        // Grosor de l√≠nea: menor = m√°s delgada
        float thickness = .999991;

        // Calculamos l√≠neas verticales: sinusoide peri√≥dica en X
        float lineX = step(thickness, abs(sin(frequency * vUv.x)));

        // Calculamos l√≠neas horizontales: desplazadas en el tiempo para animar
        // INVERTIMOS direcci√≥n restando tiempo (si fuera +u_time, va "al frente")
        float lineY = step(thickness, abs(sin(frequency * (vUv.y + u_time * 0.1))));

        // Sumamos ambas para obtener cuadr√≠cula
        float lines = clamp(lineX + lineY, 0.0, 1.0);

        // Mezclamos el color seg√∫n presencia de l√≠neas
        vec3 color = mix(u_bgColor, u_lineColor, lines);

        gl_FragColor = vec4(color, 1.0); // 1.0 = opacidad completa
      }
    `,
    side: THREE.DoubleSide // El plano puede verse desde ambos lados
  });

  // üéõÔ∏è 7. Creamos el mesh (forma + material) y lo rotamos
  const grid = new THREE.Mesh(geometry, material);

  // Por defecto, el plano est√° en el plano XY, lo rotamos a horizontal (plano XZ)
  grid.rotation.x = -Math.PI / 2;

  scene.add(grid); // A√±adimos el plano a la escena

  // üîÅ 8. Animamos en bucle
  function animate(time) {
    requestAnimationFrame(animate);

    // Convertimos el tiempo de milisegundos a segundos y lo pasamos al shader
    uniforms.u_time.value = time * 0.00005;

    // Renderizamos la escena desde la perspectiva de la c√°mara
    renderer.render(scene, camera);
  }

  animate(); // Comenzamos la animaci√≥n
</script>
</body>
</html>
